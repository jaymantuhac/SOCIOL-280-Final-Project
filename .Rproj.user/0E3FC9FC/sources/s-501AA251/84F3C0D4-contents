# SOCIOL 280: Homewrok 3
# Code generated by Jay Mantuhac (adapted from classwork R code)

#Load packages and dataset
library(pacman)
pacman::p_load(ggplot2, 
               sna,
               statnet,
               RSiena,
               psych,
               car,
               stringr,
               gdata,
               cluster,
               reshape2,
               dplyr,
               openxlsx,
               gridExtra,
               influenceR,
               igraph,
               cowplot,
               ggpubr,
               magick,
               ergMargins,
               tnet,
               tidyverse)

data(coleman)

time1 <- coleman[1,,]
time2 <- coleman[2,,]

#Question 1

#Finding cliques
cliques <- clique.census(time2,clique.comembership="bysize")
cliques$clique.count
cliques$cliques

#Symmetrize the network
time2sym <- symmetrize(time2,rule='weak')
time2sym.cliques <- clique.census(time2sym,clique.comembership="bysize")

maxClq <- apply((time2sym.cliques$clique.count[,-1]>0)*as.numeric(rownames(time2sym.cliques$clique.count)),2,max)
#Color codes by largest clique
gplot(time2sym, displaylabels=T, usearrows=F, vertex.cex=maxClq/3, vertex.col=maxClq)  # adjust node size

#k cores
time2sym_kcore <- kcores(time2sym,mode="graph")
gplot(time2sym,displaylabels=T, usearrows = F, vertex.col=time2sym_kcore)

# I'll use the kcores algorithm in this case

# Question 2 (community algorithms in igraph)
inet_time2sym <- graph.adjacency(time2sym, mode=c("undirected"), diag=FALSE)
fr <- layout.fruchterman.reingold(inet_time2sym)  
plot.igraph(inet_time2sym, layout=fr)

# Fast greedy community detection algorithm
fg <- fastgreedy.community(inet_time2sym)
names(fg)
plot(fg$modularity)
fg$modularity==max(fg$modularity)
membership(fg)    # see which group each node is assigned to
#  plot the membership with colors
colbar <- rainbow(max(membership(fg))+1)     # identify one color for each community
V(inet_time2sym)$color <- colbar[membership(fg)+1]  # set the colors
plot.igraph(inet_time2sym, layout=fr) 

#Leading eigenvector algorithm
lec <- leading.eigenvector.community(inet_time2sym)
modularity(inet_time2sym,lec$membership)                # calculate the modularity
table(lec$membership)                            # frequency of each community
#  plot the network using colors for memberships
colbar <- rainbow(max(lec$membership)+1)         # identify one color for each community
V(inet_time2sym)$color <- colbar[lec$membership+1]      # set the colors
plot.igraph(inet_time2sym, layout = fr) 

# I'll use the eigenvector algorithm in this case

# Question 3
time1sym <- symmetrize(time1, rule = 'weak')

# K-cores algorithm
time1sym_kcore <- kcores(time1sym,mode="graph")
gplot(time1sym,displaylabels=T, usearrows = F, vertex.col=time1sym_kcore)

# Eigenvector community algorithm
inet_time1sym <- graph.adjacency(time1sym, mode=c("undirected"), diag=FALSE)
fr_2 <- layout.fruchterman.reingold(inet_time1sym)  
plot.igraph(inet_time1sym, layout=fr_2)

lec_2 <- leading.eigenvector.community(inet_time1sym)
colbar <- rainbow(max(lec_2$membership)+1)         # identify one color for each community
V(inet_time1sym)$color <- colbar[lec_2$membership+1]      # set the colors
plot.igraph(inet_time1sym, layout = fr_2) 


# Question 4
library(tnet)
airports <- USairport.n500.net


#Convert edgelist to sociomatrix
if(dim(airports)[2] > 2) { 
  edges <- airports[,c(1,2)]
  edgeAttrs <- airports[,-c(1,2)] 
}

rawIDs <- sort(unique(unlist(edges)))    
( N <- length(rawIDs) )          
newIDs <- seq(1:length(rawIDs))  
lookUp <- data.frame(rawIDs, newIDs)   
elNew <- matrix(NA, nrow=dim(edges)[1], ncol=2)    
elNew[] <- lookUp$newIDs[match(unlist(edges), lookUp$rawIDs)]   

# bring any attributes back into the edgelist
if(dim(airports)[2] > 2) { 
  elNew <- data.frame(elNew, edgeAttrs) 
}

# remove edges that weren't recoded
#  - this occurs if you specify rawIDs that are a subset of nodes in the edgelist
elNew <- elNew[apply(elNew, 1, function(x) sum(is.na(x)))==0,]  

# examine the new edgelist 	
head(elNew)
tail(elNew)

# turn the edgelist into a matrix (called 'mat')
mat <- matrix(0, nrow=N, ncol=N)  # create a NxN sociomatrix filled with 0's

# populate the matrix
for (i in 1:dim(elNew)[1]) {
  mat[elNew[i,1],elNew[i,2]] <- 1           # each edge is coded as 1
  #	mat[elNew[i,1],elNew[i,2]] <- elNew[i,3]  # or, to use a third column with edgeweights
}

airports_mat <- mat

# examine the sociomatrix
table(airports_mat, useNA='always')  # are the number of ties what you expect?	
table(diag(airports_mat), useNA='always')  # are there any self-ties

equiv_clust <- equiv.clust(airports_mat, method = "euclidean")

#Denogram creation
hc1 <- hclust(dist(airports_mat), method = 'complete') #Note: Also tried 'ward.D' and 'single' methods
plot(hc1)
abline(h = 11, col = 'red')

airports_bm <- blockmodel(airports_mat, equiv_clust, h = 11) #Creates 16 blocks
print(airports_bm)

airports_bm_named <- airports_bm$blocked.data
colnames(airports_bm_named) <- airports_bm$order.vector
rownames(airports_bm_named) <- airports_bm$order.vector

#Density matrix
plot(airports_bm)

#Reduced sociogram
gplot(airports_bm$block.model, diag=TRUE,vertex.cex=1, arrowhead.cex=0.25, label=airports_bm$rlabels,
      boxed.labels=FALSE, label.pos=2)

#Full sociogram shaded by block
blockMemb <- airports_bm$block.membership[order(airports_bm$order.vector)]

gplot(airports_mat, vertex.col=blockMemb,
      usearrows=F, label.cex=.7, vertex.cex=1.5)
